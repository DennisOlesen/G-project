%{
(* HEADER *)
load "AbSyn";
open AbSyn;
%}

/* DECLARATIONS */
%start Prog

%token <Pos> PROGRAM FUNCTION PROCEDURE
%token <Pos> LPAREN RPAREN SLPAREN SRPAREN CLPAREN CRPAREN
%token <Pos> BEGIN END
%token <Pos> SEMICOLON COLON COMMA DOT
%token <Pos, Ident> ID
%token <Pos> VAR
%token <Pos> INT CHAR BOOL ARRAY OF
%token <Pos> NUMLIT LOGICLIT CHARLIT STRINGLIT
%token <Pos> PLUS MINUS TIMES SLASH EQUALS LT GT AND OR NOT
%token <Pos> IF ELSE THEN
%token <Pos> WHILE DO
%token <Pos> RETURN
%token <Pos> ASSIGN
%token <Pos> EOF EPSILON

/* add type declarations */

/* funtion declarations */
%type <Prog> Prog
%type <FunDec list> FunDecs
%type <FunDec> FunDec

/* declarations */
%type <Dec list> PDecl
%type <Dec list> Params
%type <Dec> Dec
%type <Dec list> Decs

/* function, procedure parameters and index list */
%type <Exp list> CallParams
%type <Exp list> Exps

/* types */
%type <Type> Type

/* blocks */
%type <StmtBlock> Block
%type <Dec list> DBlock
%type <Stmt list> SBlock

/* statements */
%type <Stmt list> StmtSeq
%type <Stmt> Stmt

/* L-values and expressions */
%type <LVAL> LVal
%type <Exp> Exp
%type <Exp> Op
%type <Exp> Ret

/* associativty and precedence */

%left PLUS MINUS
%left TIMES SLASH

%%

/* RULES */
Prog:
    PROGRAM ID SEMICOLON FunDecs EOF    { $4 }

FunDecs:
    FunDecs FunDec                  { $2 @ [$1] }
  | FunDec                          { [$1]      }

FunDec:
    FUNCTION ID LPAREN PDecl RPAREN COLON Type Block SEMICOLON  { Func($7, #2 $2, $4, $8, #1 $1) }
  | PROCEDURE ID LPAREN PDecl RPAREN Block SEMICOLON            { Proc(#2 $2, $4, $6, #1 $1) }

PDecl:
    Params                          { $1 }
  | EPSILON                         { [] }

Params:
    Params SEMICOLON Dec            { $1 @ [$3] }
  | Dec                             { [$1] }

Dec:
    ID COLON Type                   { Dec(#2 $1, $3, #1 $1) }

Decs:
    Decs Dec SEMICOLON              { $1 @ [$2] }
  | Dec SEMICOLON                   { [$1] }

Type:
    INT                             { Int($1) }
  | CHAR                            { Char($1) }
  | BOOL                            { Bool($1) }
  | ARRAY OF Type                   { Array($3, $1) }

Block:
    DBlock SBlock                   { ($1, $2) }

DBlock:
    VAR Decs                        { $2 }
  | EPSILON                         { [] }

SBlock:
    BEGIN StmtSeq SEMICOLON END     { $2 }
  | Stmt                            { [$1] }

StmtSeq:
    StmtSeq SEMICOLON Stmt          { $1 @ [$3]}
  | Stmt                            { [$1] }

Stmt:
    ID LPAREN CallParams RPAREN     { ProcCall(#2 $1, $3, #1 $1) }
  | IF Exp THEN Block               { IfThEl($2, $4, [], #1 $1) }
  | IF Exp THEN Block ELSE Block    { IfThEl($2, $4, $6, #1 $1) }
  | WHILE Exp DO Block              { While($2, $4, #1 $1) }
  | RETURN Ret                      { Return($2, #1 $1) }
  | LVal ASSIGN Exp                 { Assign($1, $3, #1 $2) }

LVal:
    ID                              { $1     }
  | ID SLPAREN Exps SRPAREN   /*VAR?*/{ Var($1, $3) }

Ret:
    Exp                             { $1    }
  | EPSILON                         {       }

Exp:
    NUMLIT                          {$1}
  | LOGICLIT                        {$1}
  | CHARLIT                         {$1}
  | STRINGLIT                       {$1}
  | CLPAREN Exps CRPAREN            {$1}
  | LVal                            {$1}
  | NOT Exp                         {$1}
  | Exp Op Exp                      {$1}
  | LPAREN Exp RPAREN               {$1}
  | ID LPAREN CallParams RPAREN     {/*Whatdo*/}

Op:
    PLUS                            {}
  | MINUS                           {}
  | TIMES                           {}
  | SLASH                           {}
  | EQUALS                          {}
  | LT                              {}
  | GT                              {}
  | AND                             {}
  | OR                              {}

CallParams:
    Exps                            { $1 }
  | EPSILON                         { [] }

Exps:
    Exp COMMA Exps                  { [$1] @ $3 }
  | Exp                             { [$1]      }


%%
(* TRAILER (sml code) *)
