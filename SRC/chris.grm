%{
(* HEADER *)
load "AbSyn";
open AbSyn;
%}

/* DECLARATIONS */
%start Prog

%token <Pos> PROGRAM FUNCTION PROCEDURE
%token <Pos> LPAREN RPAREN SLPAREN SRPAREN CLPAREN CRPAREN
%token <Pos> BEGIN END
%token <Pos> SEMICOLON COLON COMMA DOT
%token <Pos> ID VAR
%token <Pos> INT CHAR BOOL ARRAY OF
%token <Pos> NUMLIT LOGICLIT CHARLIT STRINGLIT
%token <Pos> PLUS MINUS TIMES SLASH EQUALS LT GT AND OR NOT
%token <Pos> IF ELSE THEN
%token <Pos> WHILE DO
%token <Pos> RETURN
%token <Pos> ASSIGN
%token <Pos> EOF EPSILON

/* add type declarations */

/* funtion declarations */
%type <Prog> Prog
%type <FunDec list> FunDecs
%type <FunDec> FunDec

/* declarations */
%type <Dec list> PDecl
%type <Dec list> Params
%type <Dec> Dec
%type <Dec list> Decs

/* function, procedure parameters and index list */
%type <Exp list> CallParams
%type <Exp list> Exps

/* types */
%type <Type> Type

/* blocks */
%type <StmtBlock> Block
%type <Dec list> DBlock
%type <Stmt list> SBlock

/* statements */
%type <Stmt list> StmtSeq
%type <Stmt> Stmt

/* L-values and expressions */
%type <LVAL> LVal
%type <Exp> Exp
%type <Exp> Op
%type <Exp> Ret

/* associativty and precedence */

%%

/* RULES */
Prog:
    PROGRAM ID SEMICOLON FunDecs EOF    { $4 }

FunDecs:
    FunDecs FunDec                  { [$2] @ [$1] }
  | FunDec                          { $1 }

FunDec:
    FUNCTION ID LPAREN PDecl RPARENT COLON Type Block SEMICOLON { Func($7, $2, $4, $8, $1) }
  | PROCEDURE ID LPAREN PDecl RPAREN Block SEMICOLON            { Proc($2, $4, $6, $1) }

PDecl:
    Params                          {}
  | EPSILON                         {}

Params:
    Params SEMICOLON Dec            {}
  | Dec                             {}

Dec:
    ID COLON Type                   { Dec($1, $3, $1) }

Decs:
    Decs Dec SEMICOLON              {}
  | Dec SEMICOLON                   {}

Type:
    INT                             { Int($1) }
  | CHAR                            { Char($1) }
  | BOOL                            { Bool($1) }
  | ARRAY OF Type                   { Array($3, $1) }

Block:
    DBlock SBlock                   {}

DBlock:
    VAR Decs                        { [$2] }
  | EPSILON                         {}

SBlock:
    BEGIN StmtSeq SEMICOLON END     {}
  | Stmt                            {}

StmtSeq:
    StmtSeq SEMICOLON Stmt          {}
  | Stmt                            {}

Stmt:
    ID LPAREN CallParams RPAREN     { ProcCall($1, $3, $1) }
  | IF Exp THEN Block               { IfTh($2, $4, $1) }
  | IF Exp THEN Block ELSE Block    { IfThEl($2, $4, $6, $1) }
  | WHILE Exp DO Block              { While($2, $4, $1) }
  | RETURN Ret                      { Return($2, $1) }
  | LVal ASSIGN Exp                 { Assign($1, $3, $2) }

LVal:
    ID                              {}
  | ID SLPAREN Exps SRPAREN         {}

Ret:
    Exp                             {}
  | EPSILON                         {}

Exp:
    NUMLIT                          {}
  | LOGICLIT                        {}
  | CHARLIT                         {}
  | STRINGLIT                       {}
  | CLPAREN Exps CRPAREN            {}
  | LVal                            {}
  | NOT Exp                         {}
  | Exp Op Exp                      {}
  | LPAREN Exp RPAREN               {}
  | ID LPAREN CallParams RPAREN     {}

Op:
    PLUS                            {}
  | MINUS                           {}
  | TIMES                           {}
  | SLASH                           {}
  | EQUALS                          {}
  | LT                              {}
  | GT                              {}
  | AND                             {}
  | OR                              {}

CallParams:
    Exps                            {}
  | EPSILON                         {}

Exps:
    Exp COMMA Exps                  {}
  | Exp                             {}


%%
(* TRAILER (sml code) *)
