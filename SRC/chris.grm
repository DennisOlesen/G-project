%{
(* HEADER *)
%}

/* DECLARATIONS */
%start Prog

%token <Pos> PROGRAM FUNCTION PROCEDURE
%token <Pos> LPAREN RPAREN SLPAREN SRPAREN CLPAREN CRPAREN
%token <Pos> BEGIN END
%token <Pos> SEMICOLON COLON COMMA DOT
%token <Pos*Ident> ID
%token <Pos> VAR
%token <Pos> INT CHAR BOOL ARRAYOF
%token <Pos*int> NUMLIT
%token <Pos*bool> LOGICLIT
%token <Pos*char> CHARLIT
%token <Pos*string> STRINGLIT
%token <Pos> PLUS MINUS TIMES SLASH EQUALS LT AND OR NOT
%token <Pos> IF ELSE THEN
%token <Pos> WHILE DO
%token <Pos> RETURN
%token <Pos> ASSIGN
%token <Pos> EOF EPSILON

/* add type declarations */

/* funtion declarations */
%type <Prog> Prog
%type <FunDec list> FunDecs
%type <FunDec> FunDec

/* declarations */
%type <Dec list> PDecl
%type <Dec list> Params
%type <Dec> Dec
%type <Dec list> Decs

/* function, procedure parameters and index list */
%type <Exp list> CallParams
%type <Exp list> Exps

/* types */
%type <Type> Type

/* blocks */
%type <StmtBlock> Block
%type <Dec list> DBlock
%type <Stmt list> SBlock

/* statements */
%type <Stmt list> StmtSeq
%type <Stmt> Stmt

/* L-values and expressions */
%type <Pos*LVAL> LVal
%type <Exp> Exp
%type <Exp option> Ret

/* associativty and precedence */

%left OR
%left AND

%left PLUS
%left MINUS
%left TIMES
%left SLASH
%right NOT

%nonassoc EQUALS LT

%nonassoc ID
%right VAR

%right IF THEN ELSE

%%

/* RULES */
Prog:
    PROGRAM ID SEMICOLON FunDecs EOF    { $4 }

FunDecs:
    FunDecs FunDec                  { $1 @ [$2] }
  | FunDec                          { [$1] }

FunDec:
    FUNCTION ID LPAREN PDecl RPAREN COLON Type Block SEMICOLON  { Func($7, #2 $2, $4, $8, $1) }
  | PROCEDURE ID LPAREN PDecl RPAREN Block SEMICOLON            { Proc(#2 $2, $4, $6, $1) }

PDecl:
    Params                          { $1 }
  | EPSILON                         { [] }

Params:
    Params SEMICOLON Dec            { $1 @ [$3] }
  | Dec                             { [$1] }

Dec:
    ID COLON Type                   { Dec(#2 $1, $3, #1 $1) }

Decs:
    Decs Dec SEMICOLON              { $1 @ [$2] }
  | Dec SEMICOLON                   { [$1] }

Type:
    INT                             { Int($1) }
  | CHAR                            { Char($1) }
  | BOOL                            { Bool($1) }
  | ARRAYOF Type                    { Array($2, $1) }

Block:
    DBlock SBlock                   { Block($1, $2) }

DBlock:
    VAR Decs                        { $2 }
  | EPSILON                         { [] }

SBlock:
    BEGIN StmtSeq SEMICOLON END     { $2 }
  | Stmt                            { [$1] }

StmtSeq:
    StmtSeq SEMICOLON Stmt          { $1 @ [$3]}
  | Stmt                            { [$1] }

Stmt:
    ID LPAREN CallParams RPAREN     { ProcCall(#2 $1, $3, #1 $1) }
  | IF Exp THEN Block               { IfThEl($2, $4, Block([], []), $1) }
  | IF Exp THEN Block ELSE Block    { IfThEl($2, $4, $6, $1) }
  | WHILE Exp DO Block              { While($2, $4, $1) }
  | RETURN Ret                      { Return($2, $1) }
  | LVal ASSIGN Exp                 { Assign(#2 $1, $3, #1 $1) }

LVal:
    ID                              { (#1 $1, Var(#2 $1)) }
  | ID SLPAREN Exps SRPAREN         { (#1 $1, Index(#2 $1, $3)) }

Ret:
    Exp                             { SOME $1 }
  | EPSILON                         { NONE }

Exp:
    NUMLIT                          { Literal(BVal(Num(#2 $1)), #1 $1) }
  | LOGICLIT                        { Literal(BVal(Log(#2 $1)), #1 $1) }
  | CHARLIT                         { Literal(BVal(Chr(#2 $1)), #1 $1) }
  | STRINGLIT                       { StrLit(#2 $1, #1 $1) }
  | CLPAREN Exps CRPAREN            { ArrLit($2, $1) }
  | LVal                            { LValue(#2 $1, #1 $1) }
  | NOT Exp                         { Not($2, $1) }
  | Exp PLUS Exp                    { Plus($1, $3, $2) }
  | Exp MINUS Exp                   { Minus($1, $3, $2) }
  | Exp TIMES Exp                   { Times($1, $3, $2) }
  | Exp SLASH Exp                   { Div($1, $3, $2) }
  | Exp EQUALS Exp                  { Equal($1, $3, $2) }
  | Exp LT Exp                      { Less($1, $3, $2) }
  | Exp AND Exp                     { And($1, $3, $2) }
  | Exp OR Exp                      { Or($1, $3, $2) }
  | LPAREN Exp RPAREN               { $2 }
  | ID LPAREN CallParams RPAREN     { FunApp(#2 $1, $3, #1 $1) }

CallParams:
    Exps                            { $1 }
  | EPSILON                         { [] }

Exps:
    Exp COMMA Exps                  { $1 :: $3 }
  | Exp                             { [$1] }


%%
