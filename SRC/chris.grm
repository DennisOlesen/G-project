%{
(* HEADER *)
open AbSyn;
%}

/* DECLARATIONS */
%start Prog

%token <Pos> PROGRAM FUNCTION PROCEDURE
%token <Pos> LPAREN RPAREN
%token <Pos> BEGIN END
%token <Pos> SEMICOLON COLON COMMA DOT
%token <Pos> ID VAR
%token <Pos> INT CHAR BOOL ARRAY OF
%token <Pos> IF ELSE THEN
%token <Pos> WHILE DO
%token <Pos> RETURN
%token <Pos> ASSIGN
%token <Pos> EOF EPSILON

/* add type declarations */

/* funtion declarations */
%type <FunDec list> Prog
%type <FunDec list> FunDecs
%type <FunDec> FunDec

/* declarations */
%type PDecl
%type Params
%type <Dec> Dec
%type <Dec list> Decs

/* function, procedure parameters and index list */
%type CallParams
%type <Exp list> Exps

/* types */
%type <Type> Type

/* blocks */
%type Block DBlock SBlock

/* statements */
%type StmtSeq Stmt

/* L-values and expressions */
%type <LVAL> LVal
%type <Exp> Exp
%type <Exp> Op

/* associativty and precedence */

%%

/* RULES */
Prog:
    PROGRAM ID SEMICOLON FunDecs EOF    { $4 }

FunDecs:
    FunDecs FunDec SEMICOLON        { [$2] @ [$1] }
  | FunDec                          { $1 }

FunDec:
    FUNCTION ID LPAREN PDecl RPARENT COLON Type Block SEMICOLON { Func($7, $2, $4, $8, $1) }
  | PROCEDURE ID LPAREN PDecl RPAREN Block SEMICOLON            { Proc($2, $4, $6, $1) }

PDecl:
    Params                          {}
  | EPSILON                         {}

Params:
    Params SEMICOLON Dec            {}
    Dec                             {}

Dec:
    ID COLON Type                   { Dec($1, $3, $1) }

%Type:
    INT                             { Int($1) }
  | CHAR                            { Char($1) }
  | BOOL                            { Bool($1) }
  | ARRAY OF Type                   { Array($3, $1) }

Block:
    DBlock SBlock                   {}

DBlock:
    VAR Decs                        { [$2] }
  | EPSILON                         {}

SBlock:
    BEGIN StmtSeq SEMICOLON END     {}
  | Stmt                            {}

StmtSeq:
    StmtSeq SEMICOLON Stmt          {}
  | Stmt                            {}

Stmt:
    ID LPAREN CallParams RPAREN     { ProcCall($1, $3, $1) }
  | IF Exp THEN Block               { IfThEl($2, $4, $4, $1) }
  | IF Exp THEN Block ELSE Block    { IfThEl($2, $4, $4, $1) }
  | WHILE Exp DO Block              { While($2, $4, $1) }
  | RETURN Ret                      { Return($2, $1) }
  | LVal ASSIGN Exp                 { Assign($1, $3, $2) }

%%
(* TRAILER (sml code) *)
